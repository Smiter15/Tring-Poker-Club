---
import { supabase } from 'src/db/supabase';
import { getOrdinal } from 'src/utils';

import Layout from '@layouts/Layout.astro';
import Table from '@components/Table';
import FilterableKnockoutChart from '@components/FilterableKnockoutChart';

// NEW
import PlayerSeasonCard from 'src/components/PlayerSeasonCard';

import styles from './_players.module.css';

export async function getStaticPaths() {
  const { data: players, error } = await supabase
    .from('players')
    .select('slug');

  if (error || !players) {
    console.error('âŒ Failed to load player slugs:', error);
    return [];
  }
  return players.map((p) => ({ params: { slug: p.slug } }));
}

const { slug } = Astro.params as { slug: string };

// â”€â”€â”€ Player â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const { data: rawPlayer, error: playerError }: any = await supabase
  .from('players')
  .select(
    `
    id,
    first_name,
    last_name,
    image_url,
    nickname,
    bio
  `,
  )
  .eq('slug', slug)
  .single();

if (playerError || !rawPlayer) {
  console.error('âŒ Could not load player:', playerError);
  throw new Error('Player not found');
}

// â”€â”€â”€ This playerâ€™s game results incl game metadata â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const { data: rawResults, error: resultsError } = await supabase
  .from('game_results')
  .select(
    `
    place,
    points,
    game:games!game_results_game_id_fkey(
      id,
      slug,
      season_id,
      season_game,
      played_on
    )
  `,
  )
  .eq('player_id', rawPlayer.id);

if (resultsError || !rawResults) {
  console.error('âŒ Could not load game results:', resultsError);
  throw new Error('Game results not found');
}

// â”€â”€â”€ fetch ALL rows for those same games, so we can count participants AND find last place â”€â”€
const gameIds = rawResults.map((r: any) => r.game.id);

const { data: allResultsForGames, error: countError } = await supabase
  .from('game_results')
  .select('game_id, place')
  .in('game_id', gameIds);

if (countError || !allResultsForGames) {
  console.error('âŒ Could not load participant counts:', countError);
  throw new Error('Counts not found');
}

const countsByGame: Record<number, number> = {};
const maxPlaceByGame: Record<number, number> = {};

allResultsForGames.forEach((r: any) => {
  const gid = Number(r.game_id);
  const place = Number(r.place);

  countsByGame[gid] = (countsByGame[gid] || 0) + 1;
  maxPlaceByGame[gid] = Math.max(maxPlaceByGame[gid] || 0, place);
});

// â”€â”€â”€ helpers / player display data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const formatDate = (iso: string) => {
  const d = new Date(iso);
  const dd = String(d.getDate()).padStart(2, '0');
  const mm = String(d.getMonth() + 1).padStart(2, '0');
  const yy = String(d.getFullYear()).slice(-2);
  return `${dd}/${mm}/${yy}`;
};

const player = {
  firstName: rawPlayer.first_name,
  lastName: rawPlayer.last_name,
  image: rawPlayer.image_url,
  nickname: rawPlayer.nickname,
  bio: rawPlayer.bio || '',
};

// wins
const { count: wins } = await supabase
  .from('game_results')
  .select('*', { count: 'exact', head: true })
  .eq('place', 1)
  .eq('player_id', rawPlayer.id);

// group by season (numeric season_id)
const seasonsMap: Record<number, typeof rawResults> = {};
rawResults.forEach((r: any) => {
  const sid = Number(r.game.season_id);
  (seasonsMap[sid] ||= []).push(r);
});

const seasonNumbers = Object.keys(seasonsMap)
  .map(Number)
  .sort((a, b) => a - b);

// â”€â”€â”€ Knockouts (used for chart + season card rivals) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const { data: rawKOs, error: koError } = await supabase
  .from('game_knockouts')
  .select(
    `
    season_id,
    game_id,
    killer_id,
    victim_id,
    killer:players!game_knockouts_killer_id_fkey(
      slug,
      first_name,
      nickname,
      prefer_nickname,
      image_url
    ),
    victim:players!game_knockouts_victim_id_fkey(
      slug,
      first_name,
      nickname,
      prefer_nickname,
      image_url
    )
  `,
  )
  .or(`killer_id.eq.${rawPlayer.id},victim_id.eq.${rawPlayer.id}`);

if (koError) {
  console.error('âŒ Could not load knockouts:', koError);
}

const displayName = (p: any) =>
  p?.prefer_nickname ? p?.nickname : p?.first_name;

// â”€â”€â”€ Season meta for dropdown + season review link â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const { data: seasonsMeta } = await supabase
  .from('seasons')
  .select('id, name, slug')
  .in('id', seasonNumbers);

const seasonMetaById: Record<number, any> = {};
(seasonsMeta ?? []).forEach((s: any) => (seasonMetaById[Number(s.id)] = s));

// tie-aware official place/points per season for this player
const { data: playerSeasonResults } = await supabase
  .from('season_results')
  .select('season_id, place, points')
  .eq('player_id', rawPlayer.id)
  .in('season_id', seasonNumbers);

const seasonResultById: Record<number, { place: number; points: number }> = {};
(playerSeasonResults ?? []).forEach((r: any) => {
  seasonResultById[Number(r.season_id)] = {
    place: Number(r.place),
    points: Number(r.points),
  };
});

// â”€â”€â”€ Build stats per season for PlayerSeasonCard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const seasonStatsById: Record<number, any> = {};

seasonNumbers.forEach((sid) => {
  const rows = seasonsMap[sid] || [];
  const sorted = rows
    .slice()
    .sort(
      (a: any, b: any) =>
        Number(a.game.season_game) - Number(b.game.season_game),
    );

  let totalPoints = 0;
  let gold = 0,
    silver = 0,
    bronze = 0,
    bubble = 0,
    poop = 0;

  let emojiTrail = '';

  sorted.forEach((r: any) => {
    const gid = Number(r.game.id);
    const place = Number(r.place);
    const pts = Number(r.points) || 0;

    totalPoints += pts;

    if (place === 1) {
      gold++;
      emojiTrail += 'ğŸ¥‡';
    } else if (place === 2) {
      silver++;
      emojiTrail += 'ğŸ¥ˆ';
    } else if (place === 3) {
      bronze++;
      emojiTrail += 'ğŸ¥‰';
    } else if (place === 4) {
      bubble++;
      emojiTrail += 'ğŸ«§';
    } else if (place === (maxPlaceByGame[gid] ?? -1)) {
      poop++;
      emojiTrail += 'ğŸ’©';
    }
  });

  const gamesPlayed = sorted.length;
  const avgPoints =
    gamesPlayed > 0 ? Number((totalPoints / gamesPlayed).toFixed(2)) : 0;

  // KO stats for this season (only if KO rows exist and season_id >= 4)
  const koForSeason = (rawKOs ?? []).filter(
    (k: any) => Number(k.season_id) === Number(sid) && Number(sid) >= 4,
  );

  let ko: any = undefined;

  if (koForSeason.length > 0) {
    let kills = 0;
    let deaths = 0;

    const rivalsMap: Record<
      string,
      {
        opponentName: string;
        opponentSlug?: string;
        opponentImage?: string;
        kills: number;
        deaths: number;
      }
    > = {};

    koForSeason.forEach((k: any) => {
      const amKiller = Number(k.killer_id) === Number(rawPlayer.id);
      const other = amKiller ? k.victim : k.killer;
      const otherName = displayName(other);

      if (!otherName) return;

      rivalsMap[otherName] ||= {
        opponentName: otherName,
        opponentSlug: other?.slug,
        opponentImage: other?.image_url ?? undefined,
        kills: 0,
        deaths: 0,
      };

      if (amKiller) {
        kills++;
        rivalsMap[otherName].kills++;
      } else {
        deaths++;
        rivalsMap[otherName].deaths++;
      }
    });

    const rivals = Object.values(rivalsMap).sort(
      (a, b) =>
        b.kills + b.deaths - (a.kills + a.deaths) ||
        b.kills - a.kills ||
        a.opponentName.localeCompare(b.opponentName),
    );

    ko = { kills, deaths, rivals };
  }

  const sr = seasonResultById[sid];

  seasonStatsById[sid] = {
    seasonId: sid,
    place: sr?.place,
    points: sr?.points ?? totalPoints, // fallback
    gamesPlayed,
    avgPoints,
    gold,
    silver,
    bronze,
    bubble,
    poop,
    emojiTrail,
    ko,
  };
});

const seasonsForCard = seasonNumbers.map((sid) => ({
  seasonId: sid,
  seasonName: seasonMetaById[sid]?.name ?? String(sid),
  seasonSlug: seasonMetaById[sid]?.slug ?? undefined,
}));

const defaultSeasonId = seasonNumbers[seasonNumbers.length - 1];

// â”€â”€â”€ KO opponent stats map (used by your existing KO chart) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
type KOStat = { kills: number; deaths: number };
const statsMap: Record<string, KOStat> = {};
(rawKOs ?? []).forEach((k: any) => {
  const amKiller = Number(k.killer_id) === Number(rawPlayer.id);
  const other = amKiller ? k.victim : k.killer;
  const name = displayName(other);
  if (!name) return;
  if (!statsMap[name]) statsMap[name] = { kills: 0, deaths: 0 };
  if (amKiller) statsMap[name].kills++;
  else statsMap[name].deaths++;
});
---

<Layout title={`${player.firstName} ${player.lastName}`}>
  <div class={styles.container}>
    <section class={styles.profile}>
      {
        player.image && (
          <img
            src={player.image}
            alt={`${player.firstName} ${player.lastName}`}
            class={styles.avatar}
          />
        )
      }
      <div class={styles.profileInfo}>
        <h1 class={styles.name}>
          {player.firstName}
          {player.nickname ? ` â€œ${player.nickname}â€` : ''}
          {player.lastName}
        </h1>

        <div class={styles.stats}>
          <div class={styles.statItem}>
            <span class={styles.statNumber}>{seasonNumbers.length}</span>
            <span class={styles.statLabel}>Seasons</span>
          </div>
          <div class={styles.statItem}>
            <span class={styles.statNumber}>
              {
                Object.values(seasonsMap).reduce(
                  (sum, arr) => sum + arr.length,
                  0,
                )
              }
            </span>
            <span class={styles.statLabel}>Games</span>
          </div>
          <div class={styles.statItem}>
            <span class={styles.statNumber}>{wins}</span>
            <span class={styles.statLabel}>Wins</span>
          </div>
        </div>

        {player.bio && <article class={styles.bio}>{player.bio}</article>}
      </div>
    </section>

    {/* NEW: Season snapshot card (most recent season played + dropdown) */}
    <PlayerSeasonCard
      client:load
      seasons={seasonsForCard}
      statsBySeasonId={seasonStatsById}
      defaultSeasonId={defaultSeasonId}
    />

    <h2>Games by Season</h2>
    {
      seasonNumbers.map((seasonId) => {
        const games = seasonsMap[seasonId]
          .slice()
          .sort((a: any, b: any) => a.game.season_game - b.game.season_game);

        const tableData = games.map((r: any) => {
          const totalPlayers = countsByGame[r.game.id] || 0;
          return {
            game: r.game.season_game,
            date: formatDate(r.game.played_on),
            position: getOrdinal(r.place),
            placeNum: r.place,
            totalPlayers,
            points: r.points,
            navigate: `/games/${r.game.slug}`,
          };
        });

        return (
          <section>
            <h3 style={{ marginTop: '30px' }}>
              Season {seasonMetaById[seasonId]?.name ?? seasonId}
            </h3>
            <Table client:load data={tableData} showEmojis={true} />
          </section>
        );
      })
    }

    {
      rawKOs && rawKOs.length > 0 && (
        <section style="margin-top:50px">
          <div>
            <h2 style="margin-bottom:0">Knockouts vs Opponents</h2>
            <FilterableKnockoutChart
              client:load
              rawKOs={rawKOs}
              playerId={rawPlayer.id}
            />
          </div>
        </section>
      )
    }
  </div>
</Layout>
